---
title: "OMSS Documentation"
format: gfm
---

**omss** is a Python package for generating matrix reasoning puzzles designed to assess fluid intelligence. It allows users to generate an unlimited number of customizable puzzles across a range of difficulty levels. 


## Contents
- [Overview](#overview)
- [Installation](#installation-and-basic-example)
- - [Rules and RuleTypes](#ruletypes)
  - [Constant](#constant)
  - [Full_constant](#full_constant)
  - [Distribute_three](#distribute_three)
  - [Progression](#progression)
  - [Arithmetic](#arithmetic)
- [Elements and AttributeTypes](#elements-and-attributetypes)
  - [BigShape](#BigShape)
  - [LittleShape](#LittleShape)
  - [Line](#Line)
  - [Multiple elements](#Multiple-Elements)
- [Alternatives Generation](#alternatives-generation)
- [Seeds](#seeds)
- [Matrix Generation](#matrix-generation)
- [Output](#output)
- [Acknowledgements](#acknowledgements)




## Overview

OMSS works with **elements** which are placed in 3 x 3 matrix. These elements have a visual appearance which is determined by their **atributes**. Specific instances of these attributes may change within a row according to a logical pattern. This logical pattern is determined by the user with **Rules**.


### Function Signature

**`create_matrix(rules, alternatives=None, seed=None, alternative_seed=None, save=True, output_file=False, element_types=None, path=None)`**

#### Parameters

- **`rules`** (*required*, `dict`):  
  A dictionary containing both the `RuleType` and the `AttributeType` it applies to.

- **`alternatives`** (`int`, optional):  
  The number of alternatives to generate. Must be between 0 and 16 (can be up to 32 depending on settings).  
  Default: `None`.

- **`seed`** (`int`, optional):  
  Seed for the main matrix generation.
  Default: `None`.

- **`alternative_seed`** (`int`, optional):  
  Seed for generating alternatives.  
  Default: `None`.

- **`save`** (`bool`, optional):  
  Whether to save the matrix and alternatives to folder.  
  - `True`: Saves files to the specified path (or a default folder).  
  - `False`: Returns the matrix and alternatives as Python objects.  
  Default: `True`.

- **`output_file`** (`bool`, optional):  
  Whether to generate an extra output file with metadata about the rules, seeds, alternatives.  
  Default: `False`.

- **`element_types`** (`list` or `None`, optional):  
  Specifies which elements to include in the matrix and the order in which they will be drawn.  
  - If `None`, all elements listed in the `rules` will be used.  
  Default: `None`.

- **`path`** (`str` or `None`, optional):  
  Path where matrices and alternatives will be saved.  
  - If `None` and `save=True`, a folder named `OMSS_output` is created in the user’s Documents directory.  
  Default: `None`.

---

In the following sections, we will first cover the different **rules**, **elements**, and their **attributes**. Next, we’ll explain the process of **matrix generation**, the creation of **alternatives**, how **seeds** function, and finally, some additional **custom settings**.

---

## Installation and Basic Example

OMSS can be installed using `pip`:

```bash
pip install omss
```

or downloaded directly from the github:

```bash
git clone https://github.com/aranvhout/OMSS_generator
cd OMSS_generator
pip install .
```

Once installed downloaded the following imports are required

```{python}
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices
```


##### Example

In the example below, we will create a simple puzzle by defining Rules for an element called `BigShape`.

```{python}
#import statements
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

#the dictionary for the in which RuleTypes are coupled to AttributeTypes
rules = {
    'BigShape': [       
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    
#create the matrices
solution_matrix, problem_matrix = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

As you can see, both the **Problem Matrix** and the **Solution Matrix** are outputted. In the Problem Matrix, the last grid cell of the bottom row is intentionally left blank. Participants must infer the underlying logic from the top two rows and apply this logic to fill in the blank in the bottom row.

---

## Rules
Rules are defined by the user and determine how attributes change across columns in the matrix. Each rule is composed of a `RuleType` and an `AttributeType`. The `RuleType` defines the way in which the `AttributeType` is modified across the row.

Most `RuleTypes` are general and can operate on any `AttributeType`. However, each `AttributeType` can be governed by only one `RuleType`.

Since `RuleTypes` are general and shared across `elements`, they are discussed here. `AttributeTypes`, on the other hand, are specific to each `element` and will be addressed in the [Elements](#elements-and-attributetypes) section.



### RuleTypes
OMSS uses 5 different `RuleTypes`, namely: constant, full_constant, distribute_three, progression and arithmetic.

#### **CONSTANT**
The `CONSTANT` rule ensures that an attribute remains unchanged **within a row**.  

For example, if a `color` attribute is governed by the `CONSTANT` rule, all elements in the same row will have the same color.


######  Example
Let’s create a very straightforward matrix puzzle. We'll once again use the BigShape element and set all of its `AttributeTypes` to `CONSTANT`, ensuring that no attribute changes within any row. This creates a simple, uniform pattern and serves as a good starting point for understanding how rule definitions work.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.CONSTANT, AttributeType.SIZE)]}
    

#create the matrices
solution_matrix, problem_matrix = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

All the elements within a row are now identical. Their color, size, angle and shape are all constant.

#### **FULL_CONSTANT**
The `FULL_CONSTANT` rule ensures that an attribute remains unchanged **across the entire matrix**. It is also possible to specify the specific value of the unchanged attribute.

##### Example
Let’s simplify the previous example even further by applying the `FULL_CONSTANT` rule to the color attribute. This means that all elements in the matrix will now have the same color, as opposed to the previous case where colors were constant only within rows.
In addition we'll also apply the `FULL_CONSTANT` rule to the size attribute and fix it to a preselected value. The available size values are 'small', 'medium', and 'large'.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
problem_matrix, solution_matrix = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(problem_matrix, solution_matrix)
```

#### **DISTRIBUTE_THREE**
The `DISTRIBUTE_THREE` rule distributes **three distinct values** of an attribute across each row. For example, if the shape attribute uses this rule, each row will contain the same three different shapes (e.g., triangle, square, circle).

##### Example
Until now, our puzzles have been fairly lackluster. By applying the `DISTRIBUTE_THREE` rule, we can start creating puzzles with actual variation and a more complicated logical structure.

Let’s enhance the previous matrix by applying the `DISTRIBUTE_THREE` rule to the color attribute. This means each row will now contain three different colors, adding a more interesting pattern for the solver to detect.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

It’s also possible to apply multiple `DISTRIBUTE_THREE` rules to different `AttributeTypes` within a single matrix. Building on the previous example, we now apply a `DISTRIBUTE_THREE` rule to both the shape and color attributes. This creates an even more varied and engaging puzzle by distributing three distinct shapes and three distinct colors across each row.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```




#### **PROGRESSION**
The `PROGRESSION` rule increases or decreases the value of an attribute across a row. For example, when applied to the size attribute, element sizes will progressively grow or shrink within each row.

Attributes are represented by classes that have a defined order. The `PROGRESSION` rule follows this order to modify attribute values step-by-step. For instance, the shape attribute is ordered from simpler to more complex shapes, allowing the rule to create a logical progression.

`PROGRESSION` can be also applied to less intuitive attributes, such as color; however, doing so might produce less intuitive or meaningful results.



##### Example
To properly showcase the `PROGRESSION` rule we will introduce a new type of `element`, namely `LittleShape`. `LittleShape` is quite similar to `BigShape` in terms of its attributes and appearance, but it is a bit smaller. As a consequence, it is possible to fit multiple `LittleShape` elements a single grid.

Below we will apply a `PROGRESSION` rule to `LittleShape's` number attribute! As you can see the number of elements increases or decreases over the row.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'LittleShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.PROGRESSION, AttributeType.LITTLESHAPENUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```



#### **ARITHMETIC**
The `ARITHMETIC` rule performs **addition or subtraction operations**, and can only be applied to numeric attributes. If multiple element types share this rule, their attribute values will be added to or subtracted from one another.

##### Example
We will now use the `LittleShape` element to demonstrate the `ARITHMETIC` rule by applying it to its numeric attribute, `littleshapenumber`.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'LittleShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.ARITHMETIC, AttributeType.LITTLESHAPENUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}


#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

It’s also possible to control the direction of the arithmetic operation (addition or subtraction). Let’s recreate the previous example using the `LittleShape` element, but this time explicitly set the operation to addition.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'LittleShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.ARITHMETIC, AttributeType.LITTLESHAPENUMBER, direction = 'addition'),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

Finally, let’s see what happens when we combine multiple `elements` in a single grid and apply the `ARITHMETIC rule`. To do this, we simply need to define rules for each element and include them in the same rules dictionary.

In the example below, we combine both `LittleShape` and `BigShape`, and apply the `ARITHMETIC` rule to the NUMBER attribute of both. The resulting matrix will perform arithmetic operations across the values of both element types.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'LittleShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.ARITHMETIC, AttributeType.LITTLESHAPENUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')],
     'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.ARITHMETIC, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}

#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

Amazing! As you can see, the arithmetic operation is being combined across the two elements.

Note: It is not possible to apply the `ARITHMETIC` rule to BigShape alone, since it only supports two numeric values (0 and 1). Applying arithmetic in isolation would result in empty grids and is thus prevented by the program.


## Elements and AttributeTypes
As of yet OMSS supports three different elements. `BigShape`, `LittleShape` and `Line`.  Each of these elements has a unique visual representation and is characterized by a specific set of `AttributeTypes`. `LittleShape` and `Bigshape` share many of the same `Attributetypes`, whereas `Line` is more unique. The following section provides a detailed overview of each `element` and its associated `Attributetypes`.


### BigShape

`BigShape` supports the following `Attributetypes`:

- **`SHAPE`**  
  Defines the shapes of the BigShape object. There are currently six shapes, ordered from least to most polygonal: `TRIANGLE`, `SQUARE`, `PENTAGON`, `SEPTAGON`, and `CIRCLE`.

- **`COLOR`**  
  Specifies the color of the object. Eight color options are available: `BLUE`, `ORANGE`, `GREEN`, `BROWN`, `PURPLE`, `GRAY`, `RED`, and `YELLOW`. All hues have been selected to be colorblind-friendly.

- **`SIZE`**  
  Determines the scale of the BigShape. There are three size instances: `SMALL`, `MEDIUM`, and `LARGE`.

- **`ANGLE`**  
  Specifies the rotation angle of the BigShape object. This attribute includes 10 discrete values, increasing in 36-degree increments. It is particularly well-suited for the `PROGRESSION` rule type.

- **`NUMBER`**  
  Indicates the number of BigShape objects placed within a grid cell. By default, only a single instance (`ONE`) is supported. However, when the `ARITHMETIC` rule is applied, this attribute may be overridden (e.g., set to `NONE`) to allow for arithmetic operations on the number of elements.

##### Example
Let's uses these `Attributetypes` to create a more constrained puzzle for `Bigshape`. Specifically, we will use some of the instances above to make a puzzle of red, medium sized squares with a progression in the angle (i.e. making the triangle rotate).

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SHAPE, value = 'triangle'),
        Rule(Ruletype.PROGRESSION, AttributeType.ANGLE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.COLOR, value = 'red'),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```


### LittleShape

`LittleShape` shares nearly all `Attributetypes` with `BigShape`. However, because it is smaller in size, multiple `LittleShape` elements can be placed within a single grid cell. Consequently, its `NUMBER` `AttributeType` behaves differently. `LittleShape` supports the following `Attributetypes`:

- **`LITTLESHAPENUMBER`**  
  Indicates the number of `LittleShape` objects placed in a grid cell. Four values are available: `ONE`, `TWO`, `THREE`, and `FOUR`.

- **`SHAPE`**  
  Defines the shapes of the LittleShape object. There are currently six shapes, ordered from least to most polygonal: `TRIANGLE`, `SQUARE`, `PENTAGON`, `SEPTAGON`, and `CIRCLE`.

- **`COLOR`**  
  Specifies the color of the object. Eight color options are available: `BLUE`, `ORANGE`, `GREEN`, `BROWN`, `PURPLE`, `GRAY`, `RED`, and `YELLOW`. All hues have been selected to be colorblind-friendly.

- **`SIZE`**  
  Determines the scale of the LittleShape. There are three size instances: `SMALL`, `MEDIUM`, and `LARGE`.

- **`ANGLE`**  
  Specifies the rotation angle of the LittleShape object. This attribute includes 10 discrete values, increasing in 36-degree increments. It is particularly well-suited for the `PROGRESSION` rule type.

##### Example
Let's now see if we can make an arithmetic puzzle for the `LITTLESHAPENUMBER` attribute of `LittleShape`. We'll fix the other attributes to keep the visual appearance consistent across the puzzle. Specifically, we'll set the `COLOR` to `GREEN`, the `SIZE` to `LARGE`, and the `SHAPE` to `CIRCLE`.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'LittleShape': [       
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SHAPE, value = 'circle'),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.COLOR, value = 'green'),
        Rule(Ruletype.ARITHMETIC, AttributeType.LITTLESHAPENUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'large')]}
    

#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

### Line

As the name suggests, `Line` places a line-shaped object in the grid. It supports the following `Attributetypes`:

- **`LINETYPE`**  
  Specifies the visual style of the line. There are three options: `SOLID`, `CURVED`, and `WAVED`, placing a solid, curved, or waved line in the grid, respectively.

- **`LINENUMBER`**  
  Indicates the number of lines placed within a grid cell. Five values are available: `ONE`, `TWO`, `THREE`, `FOUR`, and `FIVE`.

- **`ANGLE`**  
  Specifies the rotation angle of the Line object. This attribute includes 10 discrete values, increasing in 36-degree increments.


##### Examples
Let's try to make a basic `Line` puzzle. For now we won't specify any specific `Attributetypes`. We will just make a Line puzzle that progresses both in `LINENUMBER` and `ANGLE`!

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'Line': [       
        Rule(Ruletype.CONSTANT, AttributeType.LINETYPE),
        Rule(Ruletype.PROGRESSION, AttributeType.ANGLE),
        Rule(Ruletype.PROGRESSION, AttributeType.LINENUMBER)]}
 
    

#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

Let's create another `Line` puzzle! Now we will put the `ANGLE` and `LINENUMBER` to constant and apply a distribute_three to `LINETYPE`. As you can see, each `LINETYPE` (waved, curved, straight) now appears once in each row.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'Line': [       
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.LINETYPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.LINENUMBER)]}
 
    
#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```


### Multiple Elements

It is also possible to combine multiple elements into a single puzzle! To do this, simply expand the `rules` dictionary by adding rule sets for additional elements.

##### Examples

Let's combine a `BigShape` and a `Line` element in one puzzle. We'll start by defining rules for `BigShape`, assigning a `DISTRIBUTE_THREE` rule to the `COLOR` attribute. Then, we'll add a `Line` entry to the dictionary with a `PROGRESSION` rule for `LINENUMBER`:

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')],

      'Line': [       
        Rule(Ruletype.CONSTANT, AttributeType.LINETYPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.PROGRESSION, AttributeType.LINENUMBER)]}
    

#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

As you can see, the `Line` element is placed on top of the `BigShape` element. Elements that are defined later in the dictionairy are drawn upon earlier elements.

It is also possible to adjust the rendering order of elements, or exclude certain elements entirely, by using the **`element_types`** argument. For example, even if `BigShape` is defined in the `rules` dictionary, we can omit it from being rendered by only specifying the `Line` element in `element_types`.


```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')],

      'Line': [       
        Rule(Ruletype.CONSTANT, AttributeType.LINETYPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.PROGRESSION, AttributeType.LINENUMBER)]}
    

#create the matrices
solution_matrix, problem_matrix, = create_matrix(rules, save = False, element_types = ['Line'])

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)

```

## Standard Rulesets

The program also includes a set of 100 predefined rule–element combinations, organized into six difficulty levels ranging from *extremely easy* to *very advanced*.

### Difficulty Levels

- **Extremely Easy**: All rules are set to `FULL_CONSTANT`.  
  Every grid in the matrix is identical, so solving the puzzle only requires basic pattern copying.  

- **Very Easy**: All rules are set to `CONSTANT`.  
  Each row in the matrix is uniform, adding slight complexity. The participant must infer that the rules apply across rows.  

- **Easy**: Exactly one rule is non-constant, introducing more complex relationships to solve.  
  Arithmetic rules and number-based rules are still avoided (except for the `Line` element).  
  These puzzles consist of a single element.  

- **Moderate**: Multiple rules are combined.  
  Arithmetic rules may be present, as well as single rules for number attributes, angle progressions, and combinations of elements.  

- **Advanced**: Arithmetic rules with non-constant aspects are included, along with triple-rule combinations, double-rule combinations for number progression and line elements, and multi-element puzzles with rules for each element.  

- **Very Advanced**: The most challenging puzzles.


---

### Using a Standard Ruleset

It is easy to use these predefined rulesets. Simply import the ruleset and use it in place of a custom rules dictionary when calling `create_matrix`.

```{python}
# Import the ruleset
from omss import ruleset

# Select the ruleset and difficulty
solution_matrix, problem_matrix = create_matrix(ruleset.easy, save=False)


```

##### Examples
In this example we will use the standard ruleset to create some relatively easy problems
```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices, ruleset

#create the matrices
solution_matrix, problem_matrix, = create_matrix(ruleset.easy, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

By re-running this cell, you can generate new problems of approximately the same difficulty*. Now let’s increase the challenge by using the moderate ruleset:

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices, ruleset

#create the matrices
solution_matrix, problem_matrix, = create_matrix(ruleset.moderate, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```


Finally, let’s see if we can generate some advanced problems. These puzzles can be quite tough!

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices, ruleset

#create the matrices
solution_matrix, problem_matrix, = create_matrix(ruleset.advanced, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

 **Note:** These difficulty levels have not been experimentally confirmed. The main reasoning for linking a puzzle to a difficulty level is that a higher number of relationships (aka rules) generally increases its difficulty. ([Matzen et al., 2010: *Recreating Raven’s*](https://www.researchgate.net/publication/44608187_Recreating_Raven's_Software_for_systematically_generating_large_numbers_of_Raven-like_matrix_problems_with_normed_properties)).


(right now we only have 80 problems, need to work on the names and we might add an additional category )
## Alternatives Generation

### Generating Alternatives

Up to this point, we have focused solely on generating puzzles. However, for these matrix problems to function as proper reasoning tasks, a set of (incorrect) alternatives must also be generated. The program handles this in two broad steps:

1. **Determining What to Modify**  
   First, the program inspects the rules that have been set for the puzzle. Based on these, it identifies which `Attributetypes` might be interesting to modify when generating alternatives. Specifically, it avoids choosing `Attributetypes` governed by `FULL_CONSTANT` and `CONSTANT` rules, since changes to these are typically too easy to spot. This process results in an ordered list of `AttributeTypes`, with the most eligible candidates for modification being placed first in the list.

2. **Tree-Based Alternative Generation**  
   Once the list of modifiable `Attributetypes` is created, the program uses a tree-based structure to generate the alternatives. It starts by copying the correct answer and applies a random modification to the first `Attributetype` in the list, producing a new variant. Both the original answer and this first modified version become the basis for the next branching step. At each subsequent level, the next `Attributetype` from the list is modified, expanding the tree.

   For example, if four alternatives (including the correct answer) are needed, only two levels of branching are required (yielding 4 variants). If five alternatives are needed, an additional split is performed to create 8 variants, from which 5 are randomly sampled.

This approach ensures that the alternatives are structurally similar to the correct answer, while systematically introducing variation across relevant `Attributetypes`. Moreover, because the generation process explicitly accounts for the rules that have been applied in the puzzle, the resulting alternatives tend to be plausible. In addition, the tree-based generation process prevents the correct answer from being inferred by simply comparing the alternatives.

##### Examples
Now let's revisit one of our earlier examples and generate alternatives for it. Specifically, we'll create a `LittleShape` matrix that uses a `DISTRIBUTE_THREE` rule for `COLOR` and a `PROGRESSION` rule for `LITTLESHAPENUMBER`. We will make four alternatives (correct answer included), by simply setting alternatives to 4!


```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'LittleShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.PROGRESSION, AttributeType.LITTLESHAPENUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix, alternatives = create_matrix(rules, alternatives =4, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix, alternatives)
```

As you can see, both the `COLOR` and `LITTLESHAPENUMBER` attributes were modified in the alternatives. This makes sense: they were the only `Attributetypes` not governed by a `CONSTANT` or `FULL_CONSTANT` rule, making them the best candidates for variation. Now let's change the setup slightly. Instead of applying a `DISTRIBUTE_THREE` rule to `COLOR`, we set it to `FULL_CONSTANT`. 

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'LittleShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.PROGRESSION, AttributeType.LITTLESHAPENUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix, alternatives = create_matrix(rules, alternatives =4, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix, alternatives)
```

Voilà! The alternatives are now still modified in terms of `LITTLESHAPENUMBER`, as this attribute is governed by a `PROGRESSION` rule. However, since `COLOR` is now set to `FULL_CONSTANT`, it is less likely to be included as modification. Instead the program selects other available AttributeTypes—such as `SHAPE` or `ANGLE`.

However, if you would increase the number of alternatives in the above example (for example to 32), at some point even the `AttributeTypes` goverend by `FULL_CONSTANT` will be modified!

Alternative generation works in the same way for matrices consisting of multiple elements. Below we will create a matrix consisting of both a `BigShape` and `Line` element


```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {'BigShape': [       
        Rule(Ruletype.DISTRIBUTE_THREE , AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')],

    'Line': [       
        Rule(Ruletype.CONSTANT, AttributeType.LINETYPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.LINENUMBER)]}
 
    

#create the matrices
solution_matrix, problem_matrix, alternatives = create_matrix(rules, alternatives =4, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix, alternatives)
```

In this case, the `Line` element remains unchanged in the alternatives. This is because all variation within the matrix comes from the `SHAPE` and `COLOR` attributes of the `BigShape` element, while all the atributes of the `Line` element are governed by a `CONSTANT` rule. Since the line does not contribute much to the underlying logic of the puzzle, the program avoids modifying it when generating alternatives.

However, if we now remove the `DISTRIBUTE_THREE` rule from the `COLOR` attribute of `BigShape` and instead apply `DISTRIBUTE_THREE` to the `LINETYPE` attribute of the `Line` element, the behavior changes. In this configuration, variation across the matrix is now partially driven by the `Line` element. As a result, when generating alternatives, the program may introduce modifications to `LINETYPE` as well.

This demonstrates how shifting rule assignments across elements directly influences which attributes are prioritized when constructing alternative options.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {'BigShape': [       
        Rule(Ruletype.DISTRIBUTE_THREE , AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')],

    'Line': [       
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.LINETYPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.LINENUMBER)]}
 
    

#create the matrices
solution_matrix, problem_matrix, alternatives = create_matrix(rules, alternatives =4, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix, alternatives)

```

### Dissimilarity Score
Each alternative that is created differs from the correct answer in one or more `AttributeTypes`. The total number of these differences is summarized by its **dissimilarity score**, which can also be outputted (see [Output](#output)). This score provides a quantitative measure of how distinct an alternative is from the correct solution.

---

## Seeds

As you might have noticed in the examples above, the matrices change each time you re-run the code. This is because both the matrix and the alternatives are generated randomly. The only constraint is that they must follow the specified rules and, in the case of alternatives, modify attributes from the preselected list.

To make the generation process reproducible, the system supports the use of **seeds**. Each matrix can be generated using a specific **matrix seed**, which ensures that the same matrix will be created every time for a given combination of elements, rules, and seed value.

Similarly, the generation of alternatives is controlled by a separate **alternative seed**. By default, even with a fixed matrix seed, the alternatives will still vary across runs. However, if the same alternative seed is used, the exact same set of alternatives will be produced.

This separation between matrix and alternative seeds allows for flexible control: you can fix the matrix while still generating new alternatives, or lock both for full reproducibility.

These seeds can also be outputted, even for matrices created without explicitly setting a seed, by using the `output_file=True` argument. When this option is enabled, the system saves both the matrix seed and the alternative seed along with the generated matrix and alternatives (see [Output](#output))..  


##### Examples,
Let's recreate one of our earlier examples, this time specifying a seed to ensure reproducibility. We do this by simply setting the `seed` parameter to `42`. This will lock the random generation process, meaning the matrix will always look the same when this seed is used.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix, alternatives = create_matrix(rules, alternatives =4, seed=42, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix, alternatives)
```

As expected, the matrix now looks exactly the same each time you run it! However, the alternatives might still differ between runs, since their generation relies on a separate random process.

To ensure the alternatives remain consistent as well, we can set a second seed: `alternative_seed`. By setting `alternative_seed=42`, we lock the generation of the alternatives, making both the matrix and its answer options fully reproducible.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix, alternatives = create_matrix(rules, alternatives =4, seed=42, alternative_seed =42, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix, alternatives)
```

It is also possible to set a seed for the alternatives **without setting a seed for the matrix**. In this case, the alternatives become more constrained:
1. Based on the same input matrix, the alternatives will always be the same—because the `alternative_seed` ensures deterministic behavior.
2. However, since the matrix itself is randomly generated (due to the absence of a `seed` for the matrix), the input to the alternatives will vary between runs.

In essence, this means that for a given combination of rules and attribute types, the same internal logic will be used to generate the list of attributes that are modified in the alternatives. While the content of the matrix changes between runs, the way in which alternatives are built from it remains fixed. This allows for some consistency in how variation is introduced in the alternatives while still producing fresh matrices each time.

---

## Matrix Generation

In this section, we explain some of the inner workings of the program, specifically we will adress how a matrix is generated in greater detail. The process involves several steps:

### Matrix Generation Process

1. **Seed Initialization**  
   First, a seed is set; either one provided by the user or a randomly generated one. This seed is then used to produce a list of 500 integers. Whenever a random value is needed, the program draws sequentially from this seed list.

2. **Rule Configuration**  
   Next, the user-defined rules are passed to a configuration module. This module checks for interactions between rules that span different element types. If such interactions are found, the rules are automatically updated to reflect these dependencies. Currently, this is primarily relevant for the **`ARITHMETIC`** rule, which can operate across multiple element types. In the future, this module may support additional cross-element rules or constraints.

3. **Matrix Construction**  
   Rules are processed separately for each element type (e.g., `BigShape`, `Line`, etc.). For each element type, the following steps are executed:

   1. A **random starting matrix** is generated, consisting of a 3 × 3 grid of elements with random instances for the `AttributeTypes`. 
   2. 
   3. This matrix serves as the foundation for applying the specified `RuleTypes` to each `AttributeType`.  
      For instance, if the first element in a row is blue and the rule specifies `CONSTANT` for the `COLOR` attribute, the entire row will be assigned that same blue color.
   4. Each rule is applied in sequence until all defined attribute types have been processed.
      -  **Note:** Any `AttributeType` without an explicitly defined `RuleType` will remain random, as the attributes in the original starting matrix are also random.

    These steps are repeated until all element matrices are generated. The matrices are then saved in a dictionary and passed to the rendering module.

4. **Rendering**  
   The rendering module draws each element matrix separately and overlays them in sequence. This means that element matrices specified later by the user are layered on top of earlier ones. This process continues until the puzzle is fully rendered for all element types.

5. **Alternative generation**
    Alternative generation is described in [Alternatives Generation](#alternatives-generation). In short, the final grid of the combined matrix (i.e., the solution) is passed to the alternative module as the starting point for generating the alternatives.

Finally, the complete matrix is outputted.



## Output

By default, the program always outputs two matrices:

- The **solution matrix** (the full, completed grid)
- The **problem matrix** (the same as the solution, but with one grid cell missing)

If alternatives have been generated, these will also be included in the output.

### Saving the Matrices

There are two main ways to handle the output of the matrices: as Python objects or as saved image files.

#### 1. Output as Python Objects

If the `save` argument is set to `False`, the matrices are returned as bitmap objects. These can then be:

- Captured and used directly in your Python script
- Plotted using the built-in omss plotting function
- Further modified, analyzed, or embedded in custom visualizations

Use the `plot_matrices` function to display them:

### `plot_matrices` Function

This function accepts three arguments:

- `solution_matrix`: the full, completed matrix  
- `problem_matrix`: the matrix with the final cell removed  
- `alternatives` *(optional)*: a list of alternative matrices, if generated

##### Example 
```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix = create_matrix(rules, save = False)

#plot the matrices
plot_matrices(solution_matrix, problem_matrix)
```

### 2. Save Directly to Local Folder

This is the **recommended method**, especially if you're generating a large number of puzzles.

To enable this:

- Set the `save` argument to `True`  
- If no path is provided, the matrices will be saved to a folder called `omss_output`, created in your **Documents** directory

> **Note:** The `omss_output` folder will be overwritten each time unless a custom path is provided. It is strongly recommended to specify a custom output path.

```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
create_matrix(rules, path = 'yourpath')
```

### Output Document

In addition to saving the matrix images, an optional output txt file may be generated if `output_file=True` is set. This file contains metadata such as:

- The matrix seed and alternative seed  
- The rules used to generate the matrix  
- A dissimilarity score for each alternative, indicating how dissimilar an alternative to the solution is  

This output file will be:

- Exported to the `output_folder` if `save=True`  
- Returned directly in Python if `save=False`

##### Example 
```{python}
import omss
from omss import Ruletype, AttributeType, Rule, create_matrix, plot_matrices

rules = {
    'BigShape': [       
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')]}
    

#create the matrices
solution_matrix, problem_matrix, alternative, output_file = create_matrix(rules, alternatives =2, save = False, output_file = True)

#print the output_file
print(output_file)
```


## Acknowledgements

This project was funded by the NWO Open Science grant (insert grantnumber and some more details).

The package itself was inspired in part by [`raven-gen`](https://github.com/shlomenu/raven-gen).  *Chi Zhang*, *Feng Gao*, *Baoxiong Jia*, *Yixin Zhu*, *Song-Chun Zhu* *Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2019*  

**omss** has been rebuilt from scratch, with a focus on flexibility, reproducibility, and suitability for human testing.


