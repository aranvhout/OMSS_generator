---
title: "Open Matrices Stimuli Set: Getting Started"
execute:
  echo: true # for code folding
  output: true # we don't wanna see all the stuff
format:
  html:
    code-fold: true
jupyter: python3
author:
  - name: Nicholas Judd
    orcid: 0000-0002-0196-9871
    degrees: PhD
  - name: Aran van Hout
    degrees: MSc

#### need to render in the terminal while in the OMSS conda env, at some point we should list env requirements?


# this is not working I think it is a weird mac issue
# jupyter:
#  kernelspec:
#    name: "conda-env-OMSS-py"
#    language: "python"
#    display_name: "OMSS"

    # https://thedatasavvycorner.com/blogs/08-quarto-conda-env
    # follow that to manage your envs
    # we will redo this with pip when we have this packaged
---



First we need to load packages and scripts, make sure to install numpy and opencv.

```{python}
from rules import Ruletype, AttributeType, Rule
from matrix import create_matrix
import cv2
```



### To do for the walkthru
- make a super basic full constant shape
- make a constant shape
- set a seed & explain problem answer seeds
- explain the rules
- explain small & large entities
- install, and make 100 items


```{python}

# Define rules for each entity
rules = {
    'BigShape': [
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SHAPE, value = 'square'),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.ARITHMETIC, AttributeType.NUMBER),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value = 'medium')],
        
    
       'Line': [
           Rule(Ruletype.CONSTANT, AttributeType.ANGLE, value = 'ONE_EIGHTY'),
           Rule(Ruletype.ARITHMETIC, AttributeType.LINENUMBER),
           Rule(Ruletype.CONSTANT, AttributeType.LINETYPE)
       
       ],
       
       
       'LittleShape': [
   #   Rule(Ruletype.PROGRESSION, AttributeType.SHAPE),
           Rule(Ruletype.CONSTANT, AttributeType.COLOR),
       
           Rule(Ruletype.CONSTANT, AttributeType.POSITION),
           Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
           Rule(Ruletype.ARITHMETIC, AttributeType.NUMBER, direction = 'subtraction'),
           Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE, value ='medium')]}

  

# Generate matrix

create_matrix(rules, alternatives=4, seed = None, alternative_seed =None , entity_types=['BigShape', 'LittleShape'], save = False)


#12345788912457

```


# Structure of matricies

#### 1) Entities
An object/shape with contanies attributes
- Big Shape, Little Shape, Line

#### 2) Attribute Types: 
Ways to change how matricies look. Classes of settings. This will depend on the Entity.

Big shape:
- Color, Shape, Size, Angle
Little Shape:
- Color, Shape, Size, Angle, Position
Line
- linetype, linenumber, Angle

#### 3) Options

Color:
Shape: 
Size:
Angle:
Position:
linetype: 
linenumber: 
Angle:

#### 4) Rules you specify for an attribute
One attribute has a rule.

Full constant: Whole matrix has the same options
Constant: Rowwise same options



# The attribute options

```{python}
#| output: true

#from render import COLOR_MAP
#print(COLOR_MAP)


from entity import Colors, Sizes
Colors._member_names_
Sizes._member_names_

```

## A super easy example 
Here we make a big shape with four alternatives

```{python}
rules = {
    'BigShape': [
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE)]}


create_matrix(rules, alternatives=4, seed = None, alternative_seed =None , entity_types=['BigShape'], save = False)
```

By default it outputs the matricies with alternativesl in a folder called "output". Yet, you can change this with the `path` arguement. Since we are not specifying a seed it will generate a different matrix (with different answer alternatives) each time.

### Seeds
Now lets rerun the above code again a couple times. As you can the returned matrix changes each time. This is because the program randomly creates the matrix, as long as it matches the settings we set. However, we can also prevent this by specifying a certain 'seed'. Below we have set the seed to 42, but it can be any integer number! Whilst rerunning this cell you see that the solution and problem matrices stay the same!

```{python}
rules = {
    'BigShape': [
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE)]}


create_matrix(rules, alternatives=4, seed = 42, entity_types=['BigShape'], save = False)

```

However, as you might have noticed, the alternatives do still vary. So if you like the problem, but don't like the alternatives so much. You can just rerun it! At times, you might prefer to also output the same alternatives for a problem:



```{python}
rules = {
    'BigShape': [
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE)]}


create_matrix(rules, alternatives=4, alternative_seed= 1, seed = 42, entity_types=['BigShape'], save = False)

```

### Rules

So far we have been creating fairly easy puzzles. One thing you might have noticed the shape, size, color and angle of the elements have been the same in each matrix! This is because we have set all those attributes to full_constant! 

If we set some of these attributes to constant, the puzzles already become a bit more difficult.

```{python}
rules = {
    'BigShape': [
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE)]}


create_matrix(rules, alternatives=4, alternative_seed=1, seed = 42, entity_types=['BigShape'], save = False)

```

Perfect! Now we are actually creating puzzles! As you can see the colours and shapes now vary between the rows! We can further increase the difficulty by setting non-constant rules for certain attributes. Below, we have set color to distribute_three

```{python}
rules = {
    'BigShape': [
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.SIZE)]}


create_matrix(rules, alternatives=4, alternative_seed=1, seed = 42, entity_types=['BigShape'], save = False)

```

If you're paying close attention you might noticed that alternatives now have also changed eventhough the seed and alternative_seed remained the same. This is because we changed the puzzle! The generator tries to create believable alternatives based upon the puzzle and the rules that have been set. Thus the alternatives both depend on the puzzle and on the seed you might have specified

Now lets further up the difficulty by adding a progression rule for size

```{python}
rules = {
    'BigShape': [
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.FULL_CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.DISTRIBUTE_THREE, AttributeType.COLOR),
        Rule(Ruletype.PROGRESSION, AttributeType.SIZE)]}


create_matrix(rules, alternatives=4, alternative_seed=1, seed = 42, entity_types=['BigShape'], save = False)

```

As you can you can have multiple rules going on in a puzzles. Most rules work on all the the attributes. There are however some exceptions (example progression and colour rule)

### different elements

So far we have been getting to know BigShape. But the program also has other elements. It's time to say hello to its brother, LittleShape 

LittleShape is a smaller variant of BigShape. It doesnt fill up the entire grid. As consequence, it can have a certain position in the grid. The attribute govering this position is called POSITION.

Let's see if can create a little shape puzzle. All we need to do is to 1) specify rules for little shape (including the position) and 2) call little shape in the function!

```{python}
rules = {
    'LittleShape': [
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.SIZE),
        Rule(Ruletype.CONSTANT, AttributeType.POSITION)]}

create_matrix(rules, alternatives=4, alternative_seed=1, seed = 42, entity_types=['LittleShape'], save = False)
```

Bam! There we go. Now let's investigate the position attribute, there are four positions little shape can have (top left, top right, bottom left, bottom right). Let's see if we set a rule for position. In the example below, we opted for a progression rule.


```{python}
rules = {
    'LittleShape': [
        Rule(Ruletype.CONSTANT, AttributeType.SHAPE),
        Rule(Ruletype.CONSTANT, AttributeType.ANGLE),
        Rule(Ruletype.CONSTANT, AttributeType.COLOR),
        Rule(Ruletype.CONSTANT, AttributeType.SIZE),
        Rule(Ruletype.PROGRESSION, AttributeType.POSITION)]}

create_matrix(rules, alternatives=4, alternative_seed=1, seed = 42, entity_types=['LittleShape'], save = False)
```

The little shape now jumps positions

